#ifndef __I2C_H__
#define __I2C_H__

/*************************************************************************
 *
 *  External API for the I2C driver
 *
 *************************************************************************/

///////////////////////////// Structs & Defines ///////////////////////////

typedef struct I2CReq {
//    volatile    I2CReqPtr   Link;
    volatile    struct I2CReq *Link;
    volatile    int8_t      Status;
    volatile    uint8_t     Control;
    volatile    uint8_t     Address;
    volatile    uint8_t     DataLen;
    union {
        volatile    uint8_t     Data[1];
        volatile    uint8_t    *DataPtr;
    };
} I2CReqStruct;
    
typedef struct I2CReq *I2CReqPtr;

// These are the return and status values
#define I2C_STATUS_WAIT         0x00
#define I2C_STATUS_SUCCESS      0x01
#define I2C_STATUS_FAILED       0xFF
#define I2C_STATUS_INCOMPLETE   0xFE
#define I2C_STATUS_NO_ACK       0xFD
#define I2C_STATUS_ERROR        0xFC

// Definitions of the different I2C busses on the board
#define I2C_BUS_MOD             0x00
#define I2C_BUS_PROG            0x01
#define I2C_BUS_EDID1           I2C_BUS_MOD
#define I2C_BUS_EDID2           I2C_BUS_PROG
#define I2C_BUS_HDCP            0x02
#define I2C_BUS_MAIN            0x03


// The VFD (currently) needs to be VERY slow
#define I2C_SPEED_FAST          0x00
#define I2C_SPEED_SLOW          0x01

#define I2C_SPEED_BUS_MASK      0x7F
#define I2C_MAKE_SPEED_BUS( SPEED, BUS )    ((((SPEED) << 4) | (BUS)) & I2C_SPEED_BUS_MASK)
// A pointer to the data is being passed
#define I2C_INDIRECT_DATA       0x80

////////////////////////////////// Functions //////////////////////////////
//
//  For all of these functions, these parameters are common:
//
//      speed_bus   : a uint8_t generated by the macro
//                      I2C_MAKE_SPEED_BUS( speed, bus )
//                      where speed is one of: I2C_SPEED_FAST | I2C_SPEED_SLOW
//                      and bus is one of I2C_BUS_*
//
//      address     : the 8 bit I2C address; I2C addresses are really 7
//                      bits, with the LSB used as the R/W bit.  So most
//                      I2C addresses are expressed as the 7 bit address
//                      left shifted by one, with a 0 in the LSB.
//  
//  The function names are fairly self explanitory.  The "Word" functions
//  assume a "little endian" architecture, which the AVR is.  All of these
//  functions are synchronous, which means that the task calling them will
//  be suspended until the operation completes.  This way, a common buffer
//  can be shared by multiple sequential requests.  Asynchronous operations
//  are possible but dangerous.  For an example of how this is done, see
//  the source code for the function I2C_Write_Array_Read_Array().
//
//  Technical details:
//
//  The I2C driver API uses a linked list of I2CReqStruct to queue up I2C
//  requests.  Each synchronous API call generates a structure on the stack
//  then adds the struct to the end of the list.  The driver services each
//  request in turn as FIFO.  When the operation is complete, the driver
//  will overwrite the Status element of the structure indicating success 
//  or failure.  In the case of asynchronous code, you must be sure the
//  compiler recognizes the "volatile" qualifier on the Status element so
//  that it does not optimize-out the memory checks for it.
//
//  The driver itself is interrupt driven.  If the request queue is empty
//  when a request is made, the API will start the I2C engine, which will
//  guarentee that an I2C Start Bit is sent out and an interrupt will be
//  generated.  From there on, the I2C interrupt service routine will handle
//  the rest of the request.  If the addressed device fails to acknowledge
//  (NACK) during the address phase, the ISR will attempt 3 retries before
//  giving up and returning a failing status I2C_STATUS_FAILED.  If the
//  addressed device fails to transfer the entire amount of data requested,
//  the ISR will return a status of I2C_STATUS_INCOMPLETE.  If there is
//  some other unexpected error on the bus like bus contention, the ISR will
//  return status of I2C_STATUS_ERROR.  Note that the failure status values
//  are all negative.
//
//  Sequential requests to the same device (same bus/speed/address) will
//  be chained together with a restart bit rather than a stop & start pair.
//  This allows the construction of arbitrarily large "read addresses" for
//  devices with multiple registers, or even multiple pages of registers
//  to be read.
//  
//  The one special rub in the I2C driver is handling stop bits.  According
//  to Atmel, their I2C engine is completely interrupt driven, and always
//  generates an interrupt at every phase of the transaction.  While this is
//  true in the general case, it is a flat out lie for the stop bit.  There
//  is absolutely no notification whatsoever after a stop bit.  For simple
//  applications, this would be fine, however this driver may have multiple
//  requests to service.  So the driver comandeers Timer 2 to generate an
//  interrupt approximately four I2C clock cycles after initiating a stop bit.
//  This interrupt serves to kick-start the I2C ISR back into action.


extern  int8_t I2C_Write_Byte( uint8_t speed_bus,
                               uint8_t address,
                               uint8_t data );

extern  int8_t I2C_Write_Word( uint8_t  speed_bus,
                               uint8_t  address,
                               uint16_t data );

extern  int8_t I2C_Write_2Bytes( uint8_t speed_bus,
                                 uint8_t address,
                                 uint8_t data0,
                                 uint8_t data1 );

extern  int8_t I2C_Write_3Bytes( uint8_t speed_bus,
                                 uint8_t address,
                                 uint8_t data0,
                                 uint8_t data1,
                                 uint8_t data2 );

extern  int8_t I2C_Write_Array( uint8_t  speed_bus,
                                uint8_t  address,
                                uint8_t  len,
                                uint8_t *data_ptr );

extern  int8_t I2C_Read_Byte( uint8_t  speed_bus,
                              uint8_t  address,
                              uint8_t *data_ptr );

extern  int8_t I2C_Read_Word( uint8_t   speed_bus,
                              uint8_t   address, 
                              uint16_t *data_ptr );

extern  int8_t I2C_Read_Addresed_Byte( uint8_t  speed_bus,
                                       uint8_t  address,
                                       uint8_t  reg_addr,
                                       uint8_t *data_ptr );

extern  int8_t I2C_Read_Array( uint8_t  speed_bus,
                               uint8_t  address,
                               uint8_t  len,
                               uint8_t *data_ptr );

extern  int8_t I2C_Write_Array_Read_Array( uint8_t  speed_bus,
                                           uint8_t  address,
                                           uint8_t  wr_len,
                                           uint8_t *wr_ptr,
                                           uint8_t  rd_len,
                                           uint8_t *rd_ptr );


/////////////////////////////////// Private Functions ///////////////////////

extern  void    I2C_Init( void );

// This is the lowest level API to enqueue a request to the I2C
extern  int8_t I2C_Add_Req( I2CReqPtr new_req );


#endif
